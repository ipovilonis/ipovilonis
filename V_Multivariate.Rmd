---
title: "Análisis multivariado"
---

```{r  , echo=FALSE, error=TRUE, fig.align='center', fig.asp=0.4, fig.width=10, fig.height=8}
knitr::opts_chunk$set(warning = FALSE, message = FALSE, echo = FALSE)

library(readxl)
library(dplyr)

# Supongamos que fisico es tu data.frame

# Paso 1: Definir los niveles y etiquetas
new_levels <- c("Concordia", "Palmar", "Gualeguaychú")
original_levels <- c("Concordia", "Palmar", "Gualeguaychu")
# Paso 2: Convertir el factor a caracteres para hacer la sustitución
fisico$site <- factor(fisico$site, levels = original_levels)

fisico<- read_excel("database.xlsx", sheet="V fisico")
fisico$year<-as.factor(fisico$year)
fisico$phenotype<-as.factor(fisico$phenotype)
fisico$site<-factor(fisico$site, levels = original_levels, labels = new_levels)
fisico$id<-as.factor(fisico$id)
fisico$pss<-as.numeric(fisico$pss)
fisico$mad<-as.numeric(fisico$mad)

fisico <- fisico[,-c(4,9,13:15)]

table_fisico <- fisico %>%
  dplyr::group_by(year, site, phenotype) %>%
  dplyr::summarise(across(c(pff, de, dp, pen, psf, ns, pss), mean, na.rm = TRUE))

color<-read_excel("database.xlsx", sheet="V color")
color$id<-as.factor(color$id)
color$year<-as.factor(color$year)
color$phenotype<-as.factor(color$phenotype)
color$mad<-as.factor(color$mad)
color$mad<-factor(color$mad,levels=c("I", "MM", "M", "SM"))
color$site<-factor(color$site,, levels = original_levels, labels = new_levels)

color<-color[,-c(4:6, 10:16)]

table_color <- color %>%
  dplyr::group_by(year, site, phenotype) %>%
  dplyr::summarise(across(c(color_L, color_a, color_b), mean, na.rm = TRUE))

quimico1<-read_excel("database.xlsx", sheet="V varqui")
quimico1$year<-as.factor(quimico1$year)
quimico1$phenotype<-as.factor(quimico1$phenotype)
quimico1$site<-factor(quimico1$site, levels = original_levels, labels = new_levels)

quimico1 <- quimico1[,-c(4:5,11:13)]

table_quimico1 <- quimico1 %>%
  dplyr::group_by(year, site, phenotype) %>%
  dplyr::summarise(across(c(fen, cloa, clob, caro, indmad, aao25, aao50, aao100, aao250), mean, na.rm = TRUE))

quimico2<-read_excel("database.xlsx", sheet="V acidezsolidos")
quimico2$year<-as.factor(quimico2$year)
quimico2$phenotype<-as.factor(quimico2$phenotype)
quimico2$site<-factor(quimico2$site, levels = original_levels, labels = new_levels)
quimico2$ph7=as.numeric(quimico2$ph7)
quimico2$mad<-as.factor(quimico2$mad)

quimico2<-quimico2[,-c(4:5,7,12)]

table_quimico2 <- quimico2 %>%
  dplyr::group_by(year, site, phenotype) %>%
  dplyr::summarise(across(c(phi, ph8, ac, ratio, brix), mean, na.rm = TRUE))

```

```{r, echo=FALSE, fig.align='center', fig.asp=0.4, fig.width=10, fig.height=8}
knitr::opts_chunk$set(warning = FALSE, message = FALSE, echo = FALSE)

datos_combinados <-  merge(table_fisico, table_color, by= c("year", "site", "phenotype"), all.y = TRUE, all.x = TRUE)
datos_combinados <-  merge(datos_combinados, table_quimico1, by= c("year", "site", "phenotype"), all.y = TRUE, all.x = TRUE)
datos_combinados <-  merge(datos_combinados, table_quimico2, by= c("year", "site", "phenotype"), all.y = TRUE, all.x = TRUE)

datos_combinados<-datos_combinados[-112,] # se quita Palmar 2022

```

```{r , echo=FALSE, fig.align='center', fig.asp=0.4, fig.width=10, fig.height=8}
knitr::opts_chunk$set(warning = FALSE, message = FALSE, echo = FALSE)

# estandarizar

# Seleccionar las columnas numéricas
numeric_cols <- sapply(datos_combinados, is.numeric)

# Estandarizar las columnas numéricas
datos_estandarizados <- datos_combinados
datos_estandarizados[, numeric_cols] <- scale(datos_combinados[, numeric_cols])

names(datos_estandarizados) <- c("Año", "Sitio", "Fenotipo", "PFF", "DMAF", "DPF", "PEN", "PSF",
                         "NS", "PSS", "L*", "a*", 
                         "b*", "PT", "CLa", "CLb", 
                         "CTC", "IM", "DPPH25", "DPPH50", 
                         "DPPH100", "DPPH250", "pH", "ph8", 
                         "ATT", "ATT/SS", "SS")

```

```{r, echo=FALSE, error=TRUE, fig.align='center', fig.asp=0.4, fig.width=20, fig.height=16}
knitr::opts_chunk$set(warning = FALSE, message = FALSE, echo = FALSE, out.width='95%')
# Cargar las librerías necesarias
library(ggplot2)
library(factoextra)

# Seleccionar solo las columnas numéricas
numeric_cols <- sapply(datos_estandarizados, is.numeric)
data_numeric <- datos_estandarizados[, numeric_cols]

# Asegurarse de que data_numeric sea un data.frame
data_numeric <- as.data.frame(data_numeric)

# Manejar valores faltantes e infinitos
# Reemplazar infinitos con NA
data_numeric[do.call(cbind, lapply(data_numeric, is.infinite))] <- NA

# Imputar valores faltantes (NA) con la media de cada columna
data_numeric <- as.data.frame(lapply(data_numeric, function(x) {
  if(is.numeric(x)) {
    return(ifelse(is.na(x), mean(x, na.rm = TRUE), x))
  } else {
    return(x)
  }
}))

# Verificar que no haya NA ni Inf
# any(is.na(data_numeric))      # Debería ser FALSE
# any(do.call(cbind, lapply(data_numeric, is.infinite)))  # Debería ser FALSE

names(data_numeric) <- c("PFF", "DMAF", "DPF", "PEN", "PSF",
                         "NS", "PSS", "L*", "a*", 
                         "b*", "PT", "CLa", "CLb", 
                         "CTC", "IM", "DPPH25", "DPPH50", 
                         "DPPH100", "DPPH250", "pH", "ph8", 
                         "ATT", "ATT/SS", "SS")

# Realizar el PCA
pca_result <- prcomp(data_numeric, center = TRUE, scale. = TRUE)

# Ver resumen del PCA
summary(pca_result)

# Ver los loadings (contribuciones de cada variable a los componentes principales)
# print(pca_result$rotation)

# Ver los scores (valores de las muestras en los componentes principales)
# head(pca_result$x)

```

```{r , echo=FALSE, fig.align='center', fig.asp=0.4, fig.width=10, fig.height=8}
knitr::opts_chunk$set(warning = FALSE, message = FALSE, echo = FALSE)

# Obtener las contribuciones de las variables a cada componente principal
pca_var <- get_pca_var(pca_result)

# Ordenar las variables por contribución para Dim.1 (PC1)
pca_var_dim1 <- pca_var$contrib[, 1] %>% sort(decreasing = TRUE)
pca_var_dim1

# Ordenar las variables por contribución para Dim.2 (PC2)
pca_var_dim2 <- pca_var$contrib[, 2] %>% sort(decreasing = TRUE)
pca_var_dim2

# Ordenar las variables por contribución para Dim.3 (PC3)
pca_var_dim3 <- pca_var$contrib[, 3] %>% sort(decreasing = TRUE)
pca_var_dim3

```

Contribución acumulada de cada variable en CP1 y CP2
```{r, echo=FALSE, fig.align='center', fig.asp=0.4, fig.width=10, fig.height=8}
knitr::opts_chunk$set(warning = FALSE, message = FALSE, echo = FALSE)

# Asegurarse de que los nombres de las variables coincidan entre los dos vectores
common_names <- intersect(names(pca_var_dim1), names(pca_var_dim2))

# Filtrar solo las variables comunes
pca_var_dim1_filtered <- pca_var_dim1[common_names]
pca_var_dim2_filtered <- pca_var_dim2[common_names]
# pca_var_dim3_filtered <- pca_var_dim3[common_names]

# Sumar las contribuciones de cada variable en los dos componentes
combined_contributions <- pca_var_dim1_filtered + pca_var_dim2_filtered #+ pca_var_dim3_filtered

# Ordenar las variables por su contribución acumulada
sorted_contributions <- sort(combined_contributions, decreasing = TRUE)

# Mostrar el resultado
sorted_contributions

```

## Supresión de variables

```{r, echo=FALSE, error=TRUE, fig.align='center', fig.asp=0.4, fig.width=20, fig.height=16}
knitr::opts_chunk$set(warning = FALSE, message = FALSE, echo = FALSE, out.width='95%')

# Filtrar los nombres de las variables con contribución mayor a 5
variables_mayores_5 <- names(sorted_contributions[sorted_contributions > 5])

# Seleccionar esas columnas del dataframe 'datos_estandarizados'
datos_filtrados <- datos_estandarizados %>%
  dplyr::select(all_of(variables_mayores_5))

# Seleccionar solo las columnas numéricas
numeric_cols <- sapply(datos_filtrados, is.numeric)
data_numeric <- datos_filtrados[, numeric_cols]

# Asegurarse de que data_numeric sea un data.frame
data_numeric <- as.data.frame(data_numeric)

# Manejar valores faltantes e infinitos
# Reemplazar infinitos con NA
data_numeric[do.call(cbind, lapply(data_numeric, is.infinite))] <- NA

# Imputar valores faltantes (NA) con la media de cada columna
data_numeric <- as.data.frame(lapply(data_numeric, function(x) {
  if(is.numeric(x)) {
    return(ifelse(is.na(x), mean(x, na.rm = TRUE), x))
  } else {
    return(x)
  }
}))

names(data_numeric) <- c("PFF", "DMAF", "L*", "DPF", "PSF",
                         "b*", "PSS", "IM", "PEN", 
                         "pH", "CLb", 
                         "CLa", "ATT/SS", "ATT", "a*", "PT", "DPPH25")

# Verificar que no haya NA ni Inf
# any(is.na(data_numeric))      # Debería ser FALSE
# any(do.call(cbind, lapply(data_numeric, is.infinite)))  # Debería ser FALSE

# Realizar el PCA
pca_result <- prcomp(data_numeric, center = TRUE, scale. = TRUE)

# Ver resumen del PCA
# summary(pca_result)

# Ver los loadings (contribuciones de cada variable a los componentes principales)
# print(pca_result$rotation)

# Ver los scores (valores de las muestras en los componentes principales)
# head(pca_result$x)

# Visualización de los resultados

# Biplot de los dos primeros componentes principales
# biplot <- biplot(pca_result, scale = 0)

# Biplot variables
# biplot_variables <- fviz_pca_biplot(pca_result, repel = TRUE,
#                 col.var = "#2E9FDF", # color de las variables
#                 col.ind = "red")

```

# Resultados PCA

Resumen
```{r , echo=FALSE, fig.align='center', fig.asp=0.4, fig.width=10, fig.height=8}
knitr::opts_chunk$set(warning = FALSE, message = FALSE, echo = FALSE)

summary(pca_result)

```

Contribuciones de las variables a cada componente principal
```{r , echo=FALSE, fig.align='center', fig.asp=0.4, fig.width=10, fig.height=8}
knitr::opts_chunk$set(warning = FALSE, message = FALSE, echo = FALSE)

# Obtener las contribuciones de las variables a cada componente principal
pca_var <- get_pca_var(pca_result)

# Ordenar las variables por contribución para Dim.1 (PC1)
pca_var_dim1 <- pca_var$contrib[, 1] %>% sort(decreasing = TRUE)
pca_var_dim1

# Ordenar las variables por contribución para Dim.2 (PC2)
pca_var_dim2 <- pca_var$contrib[, 2] %>% sort(decreasing = TRUE)
pca_var_dim2

```

Contribución acumulada de cada variable en CP1 y CP2
```{r, echo=FALSE, fig.align='center', fig.asp=0.4, fig.width=10, fig.height=8}
knitr::opts_chunk$set(warning = FALSE, message = FALSE, echo = FALSE)

# Asegurarse de que los nombres de las variables coincidan entre los dos vectores
common_names <- intersect(names(pca_var_dim1), names(pca_var_dim2))

# Filtrar solo las variables comunes
pca_var_dim1_filtered <- pca_var_dim1[common_names]
pca_var_dim2_filtered <- pca_var_dim2[common_names]
# pca_var_dim3_filtered <- pca_var_dim3[common_names]

# Sumar las contribuciones de cada variable en los dos componentes
combined_contributions <- pca_var_dim1_filtered + pca_var_dim2_filtered #+ pca_var_dim3_filtered

# Ordenar las variables por su contribución acumulada
sorted_contributions <- sort(combined_contributions, decreasing = TRUE)

# Mostrar el resultado
sorted_contributions

```

Heatmap
```{r, echo=FALSE, fig.align='center', fig.asp=0.4, fig.width=24, fig.height=20}
knitr::opts_chunk$set(warning = FALSE, message = FALSE, echo = FALSE)

library(ggplot2)
library(dplyr)
library(reshape2)
library(data.table)

library(dplyr)
# Seleccionar las columnas específicas del dataframe
# datos_filtrados <- datos_estandarizados %>%
#   dplyr::select()

# Supongamos que 'data' es tu dataframe con solo variables numéricas
calculate_p_values <- function(data) {
  num_vars <- names(data)
  p_matrix <- matrix(NA, nrow = length(num_vars), ncol = length(num_vars))
  
  for (i in 1:length(num_vars)) {
    for (j in 1:length(num_vars)) {
      if (i != j) {
        test <- cor.test(data[[num_vars[i]]], data[[num_vars[j]]], method = "pearson")
        p_matrix[i, j] <- test$p.value
      } else {
        p_matrix[i, j] <- NA
      }
    }
  }
  
  rownames(p_matrix) <- colnames(p_matrix) <- num_vars
  return(p_matrix)
}

# Convertir 'datos_combinados' a data.table y seleccionar solo las variables numéricas
dt <- as.data.table(data_numeric)
num_vars <- dt[, .SD, .SDcols = is.numeric]

# Calcular la matriz de p-valores
p_matrix <- calculate_p_values(num_vars)

# Convertir la matriz de p-valores a formato largo
p_long <- melt(p_matrix, varnames = c("Variable1", "Variable2"), value.name = "PValue")

# Añadir los símbolos de significancia
p_long$Significance <- cut(p_long$PValue, 
                            breaks = c(-Inf, 0.001, 0.01, 0.05, Inf), 
                            labels = c("***", "**", "*", ""))

# Calcular la matriz de correlación
cor_matrix <- cor(num_vars)

# Transforma la matriz de correlación a formato largo
cor_long <- melt(cor_matrix, varnames = c("Variable1", "Variable2"), value.name = "Correlation")

# Convertir Variable1 y Variable2 a caracteres
cor_long <- cor_long %>%
  dplyr::mutate(Variable1 = as.character(Variable1),
                Variable2 = as.character(Variable2))

# Filtrar para mantener solo la mitad inferior de la matriz y la diagonal
cor_long <- cor_long %>%
  dplyr::filter(Variable1 <= Variable2)

# Combinar con la matriz de p-valores
cor_long <- merge(cor_long, p_long[, c("Variable1", "Variable2", "Significance")], 
                   by = c("Variable1", "Variable2"))

# Crear el heatmap
heatmap_multivar <- ggplot(cor_long, aes(x = Variable1, y = Variable2, fill = Correlation)) +
  geom_tile() +
  scale_fill_gradient2(
    low = "red", 
    mid = "white", 
    high = "blue", 
    midpoint = 0,
    guide = guide_colorbar(
      title = "Correlación", 
      barheight = unit(1, "lines"),  
      barwidth = unit(40, "lines"),
      size=32
    )
  ) +
  geom_tile(data = cor_long %>% dplyr::filter(Variable1 == Variable2), 
            fill = "white", color = "white") +  # Cambia el color de la diagonal a blanco
  geom_text(aes(label = Significance), color = "black", size = 8) +  # Añadir significancia
  theme_minimal() +
  labs(x = "", y = "", fill = "Correlación") +
  theme(
    axis.text.x = element_blank(),  # Eliminar nombres de variables del eje x
    axis.text.y = element_blank(),  # Eliminar nombres de variables del eje y
    plot.title = element_text(hjust = 0.5, size = rel(1), color = "black"),
    legend.position = 'bottom',
    panel.grid.major = element_blank(),  # Eliminar las líneas de la cuadrícula
    text = element_text(size = 32, color = 'black'),
    axis.ticks = element_blank()  # Eliminar las marcas en los ejes
  ) +
  coord_fixed()  # Mantener la proporción de aspecto

# Añadir nombres de variables en la diagonal central
heatmap_multivar <- heatmap_multivar +
  geom_text(
    data = cor_long %>% dplyr::filter(Variable1 == Variable2), 
    aes(label = Variable1), 
    color = "black", 
    size = 12, 
    vjust = 0.5, 
    hjust = 0.2,
    angle = 0
  )

# Mostrar el gráfico
print(heatmap_multivar)


```

Proporción de contribución de cada variable a PC1, PC2 y PC3
```{r , echo=FALSE, fig.align='center', fig.asp=0.4, fig.width=24, fig.height=16}
knitr::opts_chunk$set(warning = FALSE, message = FALSE, echo = FALSE)
# Suponiendo que tienes el objeto pca_result con la salida de tu análisis PCA
library(ggplot2)
library(dplyr)
library(tidyr)

# Extraer las rotaciones (cargas) de los componentes principales
loadings <- as.data.frame(pca_result$rotation)

# Seleccionar solo las cargas para PC1, PC2 y PC3
loadings <- loadings %>%
  dplyr::select(PC1, PC2, PC3)

# Calcular la proporción de contribución para cada parámetro en cada componente
loadings <- loadings %>%
  dplyr::mutate(Variable = rownames(loadings),
         PC1 = abs(PC1) / sum(abs(PC1)),
         PC2 = abs(PC2) / sum(abs(PC2)),
         PC3 = abs(PC3) / sum(abs(PC3)))

# Convertir los datos a formato largo (long format)
loadings_long <- loadings %>%
  pivot_longer(cols = starts_with("PC"),
               names_to = "Component",
               values_to = "Contribution")

my_palette <- c(
  "#E69F00",  # Un dorado intenso
  "#CC79A7",  # Magenta
  "#56B4E9",  # Un azul brillante
  "#B11119",  # Rojo oscuro
  "#009E73",  # Verde esmeralda
  "#F0E442",  # Amarillo
  "#0072B2",  # Azul oscuro
  "#999999",  # Gris claro
  "#D55E00",  # Naranja rojizo
  "#8A2BE2",  # Azul violeta
  "#FFD700",  # Dorado
  "#F564E3",  # Rosa fuerte
  "#84BD00",  # Verde lima
  "#FF4500",  # Naranja fuerte
  "#00A08A",  # Verde azulado
  "#A52A2A",  # Marrón
  "#6A5ACD"   # Azul pizarra
)

# Crear el gráfico de barras apiladas
gg_bar_agr_PCA_multivar <- ggplot(loadings_long, aes(x = Component, y = Contribution * 100, fill = Variable)) +
  geom_bar(stat = "identity", width = 0.3, size = 2) +  # Hacer las barras más angostas con 'width'
  geom_text(aes(label = paste0(round(Contribution * 100, 1), "%")), 
            position = position_stack(vjust = 0.5), 
            size = 8, color = "black") +
  scale_fill_manual(values = my_palette) +
  labs(title = "",
       x = "Componente principal",
       y = "Porcentaje explicado") +
  theme_classic() +
  theme(text = element_text(size = 32, color = 'black'),
        legend.position = "right",
        legend.title = element_blank()) +
  theme(axis.text = element_text(color = 'black')) +
  scale_y_continuous(labels = scales::percent_format(scale = 1)) 

# Ajustar el tamaño del dispositivo gráfico si es necesario:
# ggsave("gg_bar_agr_PCA_multivar.png", gg_bar_agr_PCA_multivar, width = 10, height = 5)


gg_bar_agr_PCA_multivar

```

Scree plot para ver la varianza explicada por cada Principal component
```{r , echo=FALSE, fig.align='center', fig.asp=0.4, fig.width=24, fig.height=16}
knitr::opts_chunk$set(warning = FALSE, message = FALSE, echo = FALSE)

library(factoextra)
library(ggplot2)
library(ggrepel)

# Supongamos que ya has calculado eig_values
eig_values <- pca_result$sdev^2 / sum(pca_result$sdev^2) * 100  # Calcular % de varianza explicada
eig_values <- round(eig_values, 2)  # Redondear a dos decimales

# Crear un data frame para el gráfico
df <- data.frame(Componente = factor(1:length(eig_values)), Varianza = eig_values) %>%
  dplyr::filter(as.numeric(Componente) <= 10)

# Crear el gráfico de barras
gg_scree_multivar <- ggplot(df, aes(x = Componente, y = Varianza)) +
    geom_bar(stat = "identity", fill = "palegreen4") +
    geom_text(aes(label = Varianza), vjust = -0.5, size = 12) +
    theme_classic() +
    labs(title = "",
         x = "Componente principal",
         y = "Porcentaje de varianza (%)") +
    theme(text = element_text(size = 32, color = 'black'),
          axis.text = element_text(size = 32, color = 'black'),
          legend.position = "none")

# Mostrar el gráfico
gg_scree_multivar

```


```{r, echo=FALSE, error=TRUE, fig.align='center', fig.asp=0.4, fig.width=20, fig.height=16}
knitr::opts_chunk$set(warning = FALSE, message = FALSE, echo = FALSE, out.width='95%')

library(ggplot2)
library(factoextra)
library(dplyr)
library(ggrepel)

# Convertir los resultados del PCA a un data frame
pca_scores <- as.data.frame(pca_result$x)
pca_scores$Sitio <- datos_estandarizados$Sitio
pca_scores$Fenotipo <- datos_estandarizados$Fenotipo
pca_scores$Año <- datos_estandarizados$Año

# pca_scores <- pca_scores[,-c(4:24)]

biplot_variables_multivar <- fviz_pca_biplot(pca_result, repel = TRUE,
                                    col.var = "black", # color de las variables
                                    geom.ind = "point",
                                    label = "var", # para que solo las variables tengan etiquetas
                                    addEllipses = FALSE,
                                    labelsize=12) +
  # geom_text_repel(data = pca_scores, aes(x = PC1, y = PC2, label = Fenotipo), size = 8, box.padding = 0.5)+ 
  geom_point(data = pca_scores, 
             aes(x = PC1, y = PC2, color = Sitio), size = 12, alpha = 0.6) +
  geom_text_repel(data = coords, 
                  aes(x = PC1, y = PC2, label = rownames(coords)), 
                  size = 8, 
                  box.padding = 0.5, 
                  color = "black") +
  scale_color_manual(values = c("Concordia" = "coral1", "Palmar" = "blue3", "Gualeguaychú" = "palegreen4"))+
  labs(title = "", x = "Componente Principal 1 (42,3 %)", y = "Componente Principal 2 (21,7 %)", color = "Sitio") +
  theme_classic() +
  theme(legend.position = "bottom",
        text = element_text(size = 32, color = 'black'),
        axis.text = element_text(color = 'black'))
  # geom_text(aes(x = Inf, y = Inf, label = "A"), 
  #           hjust = 1.2, vjust = 1.2, size = 13, color = "black", fontface = "bold")

biplot_variables_multivar

biplot_variables_multivar_2 <- fviz_pca_biplot(pca_result, repel = TRUE,
                                    col.var = "black", # color de las variables
                                    geom.ind = "point",
                                    label = "var", # para que solo las variables tengan etiquetas
                                    addEllipses = FALSE,
                                    labelsize=12) +
  # geom_text_repel(data = pca_scores, aes(x = PC1, y = PC2, label = phenotype), size = 5, box.padding = 0.5)+ 
  geom_point(data = pca_scores, 
             aes(x = PC1, y = PC2, color = Año), size = 12, alpha = 0.6) +
  scale_color_manual(values = c("2019" = "#f7db20", "2021" = "#07c22c", "2022" = "#522DAD")) +
  labs(title = "", x = "Componente Principal 1 (42,3 %)", y = "Componente Principal 2 (21,7 %)", color = "Año") +
  theme_classic() +
  theme(legend.position = "bottom",
        text = element_text(size = 32, color = 'black'),
        axis.text = element_text(color = 'black'))

biplot_variables_multivar_2


```

```{r, echo=FALSE, error=TRUE, fig.align='center', fig.asp=0.4, fig.width=20, fig.height=16}
knitr::opts_chunk$set(warning = FALSE, message = FALSE, echo = FALSE, out.width='95%')

# Análisis de cluster



```

```{r, echo=FALSE, error=TRUE, fig.align='center', fig.asp=0.4, fig.width=20, fig.height=16}
knitr::opts_chunk$set(warning = FALSE, message = FALSE, echo = FALSE, out.width='95%')

```

```{r, echo=FALSE, error=TRUE, fig.align='center', fig.asp=0.4, fig.width=20, fig.height=16}
knitr::opts_chunk$set(warning = FALSE, message = FALSE, echo = FALSE, out.width='95%')

```

```{r, echo=FALSE, error=TRUE, fig.align='center', fig.asp=0.4, fig.width=20, fig.height=16}
knitr::opts_chunk$set(warning = FALSE, message = FALSE, echo = FALSE, out.width='95%')

```

# Análisis univariado

```{r  , echo=FALSE, error=TRUE, fig.align='center', fig.asp=0.4, fig.width=10, fig.height=8}
knitr::opts_chunk$set(warning = FALSE, message = FALSE, echo = FALSE)

library(readxl)
varia<- read_excel("database.xlsx", sheet="V ICC")
library(dplyr)
varia<-arrange(varia, ID)
varia$TYPE<-as.factor(varia$TYPE)
varia$VR<-as.factor(varia$VR)
varia$LEVEL<-factor(varia$LEVEL,levels=c("POB", "IND","RES"))
# varia$VR<-factor(varia$VR,levels=c("AAO", "PHE","CLO B","CAR", "CLO A","PROMQ","TTA", "TSS","TTA/ TSS","PFD", "FFW","DFW","EFD", "PROMF","DSW","SN"))

# library(Rmisc)
# resvaria <- summarySE(varia, measurevar="PORC", groupvars=c("REG","ACC"))
# resvaria

library(ggplot2)
vargg1<-ggplot(varia, aes(x=VR,y=PORC,fill=LEVEL))+
  stat_summary(fun = "mean", size = 1, geom = "bar",position="dodge", width=0.5) +
  labs(x="", y="%")+
  # facet_grid(TYPE~.)+
  theme_classic()+
  theme(plot.title = element_text(hjust = 0.5, size = rel(1.5))) +
  scale_fill_manual(values = c("red2","green3","gold")) +
  theme(legend.title=element_blank())+
  theme(legend.position='bottom')+
  theme(panel.grid.major.y = element_line(color='black'))+
  theme(panel.grid.major.x = element_blank())+
  theme(text = element_text(size=15, color='black'))+
  theme(axis.text = element_text(color='black'))
vargg1

```

* QUIM chemical variables
* FIS physical variables

* PFF Peso fresco del fruto
* DE Diámetro ecuatorial
* DP Diámetro polar
* PEN Resistencia a la penetración
* PSF Peso seco del fruto
* PSS Peso seco semilla
* IM Índice de madurez

* AAO Actividad Anti Oxidante
* CAR Carotenoides
* CLOA Clorofila a
* CLOB Clorofila b
* PHE Fenoles totales
* TSS Solidos solubles totales
* TTA Acidez Total Titulable

* POB population
* IND phenotype
* RES residual